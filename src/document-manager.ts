import * as fs from "fs";
import * as path from "path";
import { DocumentCollection } from "./lib/types";

/**
 * Document Collection Manager
 * Manages collections of PDF documents for RAG knowledge base
 */

export class DocumentManager {
  private collectionsDir = "./collections";

  constructor() {
    // Create collections directory if it doesn't exist
    if (!fs.existsSync(this.collectionsDir)) {
      fs.mkdirSync(this.collectionsDir, { recursive: true });
    }
  }

  /**
   * Create or get a document collection
   */
  getOrCreateCollection(
    collectionId: string,
    name?: string
  ): DocumentCollection {
    const collectionFile = path.join(this.collectionsDir, `${collectionId}.json`);

    // Check if collection exists
    if (fs.existsSync(collectionFile)) {
      const data = JSON.parse(fs.readFileSync(collectionFile, "utf8"));
      return {
        id: data.id,
        name: data.name,
        taxonomy: data.taxonomy,
        createdAt: new Date(data.createdAt),
        updatedAt: new Date(data.updatedAt || data.createdAt),
      };
    }

    // Create new collection (taxonomy will be generated by vectorize workflow)
    const collection: DocumentCollection = {
      id: collectionId,
      name: name || this.formatCollectionName(collectionId),
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    this.saveCollection(collection);
    return collection;
  }

  /**
   * Save collection to disk
   */
  saveCollection(collection: DocumentCollection): void {
    const collectionFile = path.join(this.collectionsDir, `${collection.id}.json`);

    const data = {
      ...collection,
      updatedAt: new Date(),
    };

    fs.writeFileSync(collectionFile, JSON.stringify(data, null, 2));
  }

  /**
   * Update collection taxonomy (from analyzer)
   */
  updateTaxonomy(collectionId: string, taxonomy: any): void {
    const collection = this.getOrCreateCollection(collectionId);
    collection.taxonomy = taxonomy;
    collection.updatedAt = new Date();
    this.saveCollection(collection);
  }

  /**
   * List all collections
   */
  listCollections(): DocumentCollection[] {
    if (!fs.existsSync(this.collectionsDir)) {
      return [];
    }

    const files = fs.readdirSync(this.collectionsDir)
      .filter(f => f.endsWith('.json'));

    return files.map(file => {
      const data = JSON.parse(
        fs.readFileSync(path.join(this.collectionsDir, file), 'utf8')
      );
      return {
        id: data.id,
        name: data.name,
        taxonomy: data.taxonomy,
        createdAt: new Date(data.createdAt),
        updatedAt: new Date(data.updatedAt || data.createdAt),
      };
    });
  }

  /**
   * Get collection by ID
   */
  getCollection(collectionId: string): DocumentCollection | null {
    const collectionFile = path.join(this.collectionsDir, `${collectionId}.json`);

    if (!fs.existsSync(collectionFile)) {
      return null;
    }

    const data = JSON.parse(fs.readFileSync(collectionFile, "utf8"));
    return {
      id: data.id,
      name: data.name,
      taxonomy: data.taxonomy,
      createdAt: new Date(data.createdAt),
      updatedAt: new Date(data.updatedAt || data.createdAt),
    };
  }

  /**
   * Delete a collection
   */
  deleteCollection(collectionId: string): boolean {
    const collectionFile = path.join(this.collectionsDir, `${collectionId}.json`);

    if (fs.existsSync(collectionFile)) {
      fs.unlinkSync(collectionFile);
      return true;
    }

    return false;
  }

  /**
   * Format collection ID into a human-readable name
   */
  private formatCollectionName(collectionId: string): string {
    return collectionId
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  /**
   * Get collection statistics
   * Note: This requires database access for full stats
   * Returns basic info from collection file only
   */
  getCollectionInfo(collectionId: string): {
    id: string;
    name: string;
    hasTaxonomy: boolean;
    createdAt: Date;
    updatedAt: Date;
  } | null {
    const collection = this.getCollection(collectionId);

    if (!collection) {
      return null;
    }

    return {
      id: collection.id,
      name: collection.name,
      hasTaxonomy: !!collection.taxonomy,
      createdAt: collection.createdAt!,
      updatedAt: collection.updatedAt!,
    };
  }
}
